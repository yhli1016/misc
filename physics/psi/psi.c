/*
 * This program outputs the wave functions of hydrogen-like atoms with specified
 * quantum number according to the analytical solution of Schrodinger's equation.
 *
 * This program requires an input file named psi.inp which must be in the 
 * following form.
 * -----------------------------------------------------------------------------
 * H21-1.real.cube    // output file name
 * 1                  // Zval
 * 2 1 -1             // n l m
 * 1/-1/0             // flavor, see more details below
 * 0. 50. 0.1         // xmin, xmax, hx of the cube
 * 0. 50. 0.1         // ymin, ymax, hy
 * 0. 50. 0.1         // zmin, zmax, hz
 * 25. 25. 25.        // x1, y1, z1 of the nucleus
 * -----------------------------------------------------------------------------
 *
 * Notes on the flavor flag:
 * Set flavor to  1 to output the real part of wave function.
 * Set flavor to -1 to output the imaginary part.
 * Set flavor to  0 to output the linear combination of wave functions with same
 * quantum number (n,l) but opposite m. The resulting wave function is always
 * real. This type of orbitals are commonly employed in chemisty. See the URL
 * for more details:
 * https://en.wikipedia.org/wiki/Table_of_spherical_harmonics#Real_spherical_harmonics
 *
 * The output is in Gaussian98 cube format.
 *
 */


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include "rnl.h"
#include "ylm.h"
#include "checkinp.h"


int main( void )
{
    // psi.inp
    char cubename[32];
    int Zval;
    int n, l, m;
    int flavor;
    double xmin, xmax, hx;
    double ymin, ymax, hy;
    double zmin, zmax, hz;
    double x1, y1, z1;

    // meshgrid information
    int NGX, NGY, NGZ;
    double xi, yi, zi;
    double dx, dy, dz;
    double r, rxy, theta, phi, gridval;

    // files used through the program
    FILE *cube, *inp;

    // global constant
    const double PI = 3.14159265358979;
    
    // loop counters
    int i, j, k;
    
    // program status
    int status;

    
    // read psi.inp
    inp = fopen( "psi.inp", "r" );
    fscanf( inp, "%s\n", &cubename );
    fscanf( inp, "%d\n", &Zval );
    fscanf( inp, "%d%d%d\n", &n, &l, &m );
    fscanf( inp, "%d\n", &flavor );
    fscanf( inp, "%lf%lf%lf\n", &xmin, &xmax, &hx );
    fscanf( inp, "%lf%lf%lf\n", &ymin, &ymax, &hy );
    fscanf( inp, "%lf%lf%lf\n", &zmin, &zmax, &hz );
    fscanf( inp, "%lf%lf%lf\n", &x1, &y1, &z1 );
    fclose( inp );
    
    // check input parameters
    status = checkinp( l, m, flavor );
    if ( status != 0 )
    {
        printf( "\nProgram exited with error code:" );
        printf( "%4d\n", status );
        printf( "Check your input" );
        printf("\n");
        return status;
    }
    else
    {
        // calculate NGX, NGY, NGZ
        NGX = (int)( ( xmax - xmin ) / hx );
        NGY = (int)( ( ymax - ymin ) / hy );
        NGZ = (int)( ( zmax - zmin ) / hz );

        // open cube file
        cube = fopen(cubename,"w");
        
        // write first 2 lines to cube
        if ( flavor == 1)
            fprintf( cube, "%36s%6d%6d%6d\n", "Real part of Psi with quantum number", n, l, m );
        else if ( flavor == -1 )
            fprintf( cube, "%36s%6d%6d%6d\n", "Imag part of Psi with quantum number", n, l, m );
        else
            fprintf( cube, "%38s%6d%6d\n",    "Combination of Psi with quantum number", n, l  );
        fprintf( cube, "Generated by programm psi.x\n");
        
        // write natom and origin of data
        fprintf( cube, "%5d%12.6f%12.6f%12.6f\n", 1, xmin, ymin, zmin  );
        
        // write mesh info
        fprintf( cube, "%5d%12.6f%12.6f%12.6f\n", NGX,  hx, 0.0, 0.0 );
        fprintf( cube, "%5d%12.6f%12.6f%12.6f\n", NGY, 0.0,  hy, 0.0 );
        fprintf( cube, "%5d%12.6f%12.6f%12.6f\n", NGZ, 0.0, 0.0,  hz );
        
        // write atoms info
        fprintf( cube, "%5d%12.6f%12.6f%12.6f%12.6f\n", Zval, 1.0*Zval, x1, y1, z1 );
        
        // entering main loop
        for ( i = 1; i <= NGX; i ++ )
        {
            xi = xmin + hx * (i-1);
            dx = xi - x1;
            
            for ( j = 1; j <= NGY; j ++ )
            {
                yi  = ymin + hy * (j-1);
                dy  = yi - y1;
                rxy = sqrt( dx*dx + dy*dy );
                if ( dy >= 0.0 )
                    phi = acos( dx / rxy );
                else
                    phi = 2.0 * PI - acos( dx / rxy );
                
                for ( k = 1; k <= NGZ; k ++ )
                {

                    zi = zmin + hz * (k-1);
                    dz = zi - z1;
                    r  = sqrt( dx*dx + dy*dy  + dz*dz );
                    theta = acos( dz / r );
                    
                    if ( r <= 1.0E-7 )
                        gridval = 0.0;
                    else
                    {
                        switch (flavor)
                        {
                            case  1: gridval = RadialFunc( Zval, n, l, r ) 
                                             * RealSphereHarm( l, m, theta, phi ); break;
                            case -1: gridval = RadialFunc( Zval, n, l, r )
                                             * ImagSphereHarm( l, m, theta, phi ); break;
                            case  0: gridval = RadialFunc( Zval, n, l, r )
                                             * CombSphereHarm( l, m, dx, dy, dz, r ); break;
                            default: gridval = 0.0; break;
                        }
                    }
                    
                    fprintf( cube, "%14.5e", gridval );
                    if ( k == NGZ || k%6==0 )
                        fprintf( cube, "\n" );
                }
            }    
        }
        
        // close cube file
        fclose(cube);

        // exit
        return 0;
    }
}
